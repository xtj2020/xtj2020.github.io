# 1、匹配

## 匹配

元字符：. ^ $  * + ? { } [ ] ( ) \ |

[ ] : 指定字符类，字符类中元字符不生效（特殊情况^开头作为非出现），是或的含义。

\ ：1、跟字符指示特殊序列；2、转义所有元字符，使得能够匹配元字符本身

特殊序列：

| 字符 |            用法            |
| ---- | :------------------------: |
| .    | 匹配除换行符之外的任意字符 |
| \d   |            数字            |
| \D   |           非数字           |
| \s   |            空白            |
| \S   |           非空白           |
| \w   |            单词            |
| \W   |           非单词           |

\d\d\d会精准匹配三位数，等价于{3}

\s可以使用重复

[^abc] 将匹配除abc的单个字符

## 重复

*匹配零次或多次，贪婪的，尽可能多的匹配，不匹配退回进行匹配。

+匹配一次或多次，至少一次

？匹配一次或零次

{m,n}至少m次，至多n次

## 零宽度

\b 位于字边界

｜或 “or”具备非常低的优先级

^只会在字符串的开头匹配，即使设置MULTILINE也在字符串中每个换行符后进行匹配

$匹配行的末尾

\\a起始

\\b 前面是一个单词，后面是一个非单词

\A

\Z

## 捕获分组

( )只会捕获（）内的内容

嵌套的捕获组，按顺序进行提取

可以在捕获组后加？这样不会影响前面的捕获组

## 非捕获

(? : ...) 只做匹配，不做捕获

（？=...）前向断言 只匹配对的

（? ! ...）后向断言 只匹配不对的

# 2、应用编译	

## 编译与应用

compile

math 只匹配字符串的开始

search 对整个字符串进行搜索

findall 获取所有匹配的字符串，返回一个列表

finditer 返回一个迭代器

## 编译标志

A

S

I

L

M

X

#  3、修改	

split() 将字符串拆分为一个列表

```
import re
text = 'a,b,c,,,d'
reobj = re.compile（'[,]+'）
reobj.spilt(text)
#等价于
re.spilt('[,]+',text)
```

sub() 找到所有子字符，并进行替换
sub('具体模式'，源字符串)，返回值是一个字符串

subn() 会返回新字符串和替换次数

# 代码基准

```
[0-9][0-9]可以实现两位数字的匹配，用[0-99]会出现匹配单位数
```

